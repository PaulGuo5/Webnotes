# Operaing System 学习笔记
>    本文来源于网络，可能存在错漏之处，仅供参考。

## 线程与进程
>    [参考](https://blog.csdn.net/xiongluo0628/article/details/81461053)

### 1. 定义
+ *进程*是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。
+ *线程*是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。  

### 2. 关系
+ 一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行。
+ 相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。

### 3. 区别
+ ![线程和进程的区别](https://raw.githubusercontent.com/PaulGuo5/Webnotes/master/img/processesVSthreads.png)
+ 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

- 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.
- 线程的划分尺度小于进程，使得多线程程序的并发性高。
- 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
- 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 
- 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 

### 4. 优缺点： 
+ 线程开销小，但不利于资源的管理和保护；进程与之相反。

### 5. 线程的并发与并行
>    [参考](https://blog.csdn.net/qq_33290787/article/details/51790605)

+ 并发：排队等候，唤醒，执行（微观）；同时在被处理（宏观）；在CPU比较繁忙，资源不足的时候（开启了很多进程），操作系统只为一个含有多线程的进程分配仅有的CPU资源，这些线程就会为自己尽量多抢时间片，这就是通过多线程实现并发，线程之间会竞争CPU资源争取执行机会。

+ 并行：同时运行（微观，宏观）；Parallelism，即并行，指两个或两个以上事件（或线程）在同一时刻发生，是真正意义上的不同事件或线程在同一时刻，在不同CPU资源呢上（多核），同时执行。在CPU资源比较充足的时候，一个进程内的多线程，可以被分配到不同的CPU资源，这就是通过多线程实现并行。

- 至于多线程实现的是并发还是并行？上面所说，所写多线程可能被分配到一个CPU内核中执行，也可能被分配到不同CPU执行，分配过程是操作系统所为，不可人为控制。所有，如果有人问我我所写的多线程是并发还是并行的？我会说，都有可能。
- 不管并发还是并行，都提高了程序对CPU资源的利用率，最大限度地利用CPU资源。

## windows的内存管理
>    [windows的内存管理](https://blog.csdn.net/xiongluo0628/article/details/81461053)

1. 虚拟内存： 
- 最适合用来管理大型对象或者结构数组 
2. 内存映射文件： 
- 最适合用来管理大型数据流（通常来自文件）以及在单个计算机上运行多个进程之间共享数据 
3. 内存堆栈： 
- 最适合用来管理大量的小对象

### windows 内存管理方式主要分为：页式管理，段式管理，段页式管理。
>    [Windows内存管理和linux内存管理](https://www.cnblogs.com/wuchanming/p/4370160.html)

1. 页式管理
- 页式管理的基本原理是将各进程的虚拟空间划分为若干个长度相等的页；页式管理把内存空间按照页的大小划分成片或者页面，然后把页式虚拟地址与内存地址建立一一对应的页表；并用相应的硬件地址变换机构来解决离散地址变换问题。页式管理采用请求调页或预调页技术来实现内外存存储器的统一管理。其优点是没有外碎片，每个内碎片不超过页的大小。缺点是,程序全部装入内存，要求有相应的硬件支持。例如地址变换机构缺页中断的产生和选择淘汰页面等都要求有相应的硬件支持。这增加了机器成本，增加了系统开销。
2. 段式管理
- 段式管理的基本思想是把程序按照内容或过程函数关系分段，每段都有自己的名字。一个用户作业或进程所包括的段对应一个二维线形虚拟空间，也就是一个二维虚拟存储器。段式管理程序以段为单位分配内存，然后通过地址映射机构把段式虚拟地址转换为实际内存物理地址。其优点是可以分别编写和编译，可以针对不同类型的段采用不同的保护，可以按段为单位来进行共享，包括通过动态链接进行代码共享。缺点是会产生碎片。
3. 段页式管理
- 为了实现段页式管理，系统必须为每个作业或进程建立一张段表以管理内存分配与释放、缺段处理等。另外由于一个段又被划分成了若干个页。每个段必须建立一张页表以把段中的虚页变换成内存中的实际页面。显然与页式管理时相同，页表中也要有相应的实现缺页中断处理和页面保护等功能的表项。段页式管理的段式管理与页式管理方案结合而成的所以具有他们两者的优点。但反过来说，由于管理软件的增加，复杂性和开销也就随之增加了。另外需要的硬件以及占用的内存也有所增加。使得速度降下来。

## 中断和轮询
>    [中断和轮询参考](https://blog.csdn.net/Lrrent/article/details/51103252)

- 外部设备与中央处理器交互方式：中断和轮询。

### 轮询
- 很多I/O设备都有一个状态寄存器，用于描述设备当前的工作状态，每当设备状态发生改变时，设备将修改相应状态寄存器位。
- 通过不断查询设备的状态寄存器，CPU就可以了解设备的状态，从而进行必要的I/O操作。
- 对I/O设备的程序轮询的方式，是早期的计算机系统对I/O设备的一种管理方式。
- 它定时对各种设备轮流询问一遍有无处理要求。轮流询问之后，有要求的就加以处理。在处理I/O设备的要求之后，处理机返回继续工作。
- 尽管轮询需要时间，但轮询要比I/O设备的速度要快得多，所以一般不会发生不能及时处理的问题。
- 当然，再快的处理机，能处理的输入输出设备的数量也是有一定限度的。而且，程序轮询毕竟占据了CPU相当一部分处理时间，因此程序轮询是一种效率较低的方式，现代计算机系统中已很少应用。 

### 中断
- 打断正在进行中的工作。
- 中断不需要处理器轮询设备的状态，设备在自己发生状态改变时将主动发送一个信号给处理器（PIC），后者在接收到这一通知信号时，会挂起当前正在执行的任务转而去处理响应外设的中断请求。
- 中断通知机制通过硬件信号异步唤起处理器的注意，解决了外部设备与处理器之间速度不匹配导致的资源浪费问题。

### 轮询和中断对比
- 轮询效率低，等待时间很长，CPU利用率不高；中断容易遗漏一些问题，CPU利用率高。






